---
title: Java-HashMap
---


Java 中的 `HashMap` 是最常用的集合类之一，也是面试中被问频次最高的数据结构。它是基于哈希表（Hash Table）实现的 `Map` 接口，用于存储 Key-Value 键值对。

以下从 **基本介绍**、**底层数据结构原理**、**版本迭代（JDK 1.7 vs 1.8）** 三个方面为你详细解读。

---

### 一、 HashMap 基本介绍

1.  **定义**：`HashMap` 是一个散列表，它存储的内容是键值对（Key-Value）映射。
2.  **特点**：
    *   **无序性**：不保证映射的顺序，特别是该顺序可能会随着时间的推移发生变化（比如扩容后）。
    *   **Key/Value 允许为 Null**：允许一个 Key 为 `null`，多个 Value 为 `null`。
    *   **非线程安全**：在多线程环境下，如果不做同步处理，可能会导致数据丢失或死循环（JDK 1.7）。
3.  **时间复杂度**：在理想情况下，添加、删除、查找的时间复杂度均为 $O(1)$。

---

### 二、 数据结构原理

`HashMap` 的核心原理在于 **Hashing（哈希）**。它通过将 Key 的 HashCode 映射到数组的下标来存储数据。

#### 1. 核心组成
宏观上，HashMap 是 **数组（Array） + 链表（Linked List） + 红黑树（Red-Black Tree，JDK 1.8新增）** 的结合体。

*   **数组（Bucket Array）**：这是 HashMap 的主体。数组的每个位置称为一个“桶（Bucket）”。
*   **链表/红黑树**：用于解决 **哈希冲突（Hash Collision）**。当两个不同的 Key 计算出相同的数组下标时，它们会存储在同一个桶中，形成链表或树。

#### 2. PUT 存储过程
1.  **计算 Hash**：拿到 Key，调用 `hashCode()` 并进行扰动函数处理（高位运算），得到最终的 hash 值。
2.  **计算下标**：通过 `(n - 1) & hash` 计算该 Key 在数组中的索引位置（`n` 为数组长度）。
    *   *注意：这也是为什么 HashMap 的容量必须是 2 的幂次方，因为这样 `(n-1)` 的二进制全是 1，位运算等同于取模，但效率更高。*
3.  **冲突处理**：
    *   如果该位置为空，直接放入。
    *   如果该位置已有数据（发生了 Hash 冲突），则遍历链表/红黑树：
        *   如果 Key 相同（用 `equals` 判断），覆盖旧 Value。
        *   如果 Key 不同，则追加到链表末尾（JDK 1.8）或插入树中。
4.  **扩容机制**：如果当前元素个数 > `capacity * loadFactor`（默认 16 * 0.75 = 12），则触发 `resize()`，数组大小翻倍，并重新分配所有元素位置。

---

### 三、 版本迭代历史：JDK 1.7 vs JDK 1.8

这是 HashMap 演变中最关键的部分，也是性能提升的分水岭。

#### 1. 底层结构的区别
*   **JDK 1.7**：**数组 + 链表**。
    *   不管链表多长，都一直挂在链表上。极端情况下（所有 Key 的 Hash 冲突），查询效率会退化为 $O(n)$。
*   **JDK 1.8**：**数组 + 链表 + 红黑树**。
    *   为了优化长链表的查询效率，当 **链表长度 > 8** 且 **数组长度 >= 64** 时，链表会转换为 **红黑树**。
    *   查询效率从 $O(n)$ 提升至 $O(\log n)$。
    *   当树中节点数降至 6 时，会退化回链表。

#### 2. 插入方式的区别（重要）
*   **JDK 1.7**：**头插法（Head Insertion）**。
    *   新来的节点插在链表的头部。
    *   *设计初衷*：作者认为后插入的数据被访问的概率更大（局部性原理）。
    *   *致命缺陷*：在并发扩容（resize）时，由于头插法会改变链表元素的顺序，容易导致 **死循环（Infinite Loop）**，即链表形成闭环。
*   **JDK 1.8**：**尾插法（Tail Insertion）**。
    *   新来的节点插在链表的尾部。
    *   *优势*：扩容后保持链表原有顺序，**彻底解决了并发扩容下的死循环问题**。

#### 3. 扩容（Rehash）逻辑的优化
*   **JDK 1.7**：扩容时，需要对每个元素重新计算 Hash 值，并取模计算新下标。消耗性能。
*   **JDK 1.8**：利用了 2 的幂次方的规律。
    *   扩容后，元素的新位置要么在 **原位置**，要么在 **原位置 + 旧数组长度**。
    *   判断方法：只需要看 Hash 值新增的那一位比特是 0 还是 1。
    *   *优势*：省去了重新计算 Hash 的开销，效率极大提升。

#### 4. 扰动函数（Hash 算法）的简化
*   **JDK 1.7**：为了防止 Hash 冲突，进行了 4 次位运算 + 5 次异或运算，比较复杂。
*   **JDK 1.8**：简化为 `(h = key.hashCode()) ^ (h >>> 16)`（高16位和低16位异或）。因为引入了红黑树，即使冲突稍多一点，查询效率也能保证，所以牺牲了一点 Hash 的散列性换取了计算速度。

---

### 四、 总结对比表

| 特性 | JDK 1.7 | JDK 1.8 |
| :--- | :--- | :--- |
| **底层结构** | 数组 + 链表 | 数组 + 链表 + **红黑树** |
| **链表插入方式** | **头插法** (并发扩容可能死循环) | **尾插法** (解决了死循环) |
| **扩容后位置** | 重新 Hash 计算 | 原位置 或 原位置+旧容量 |
| **时间复杂度(最差)** | $O(n)$ | $O(\log n)$ (树化后) |
| **初始化时机** | 单独初始化方法 | 第一次 `put` 时懒加载 |

### 五、 面试常见追问
1.  **为什么默认加载因子（Load Factor）是 0.75？**
    *   这是空间和时间的权衡。
    *   如果是 1.0，空间利用率高，但 Hash 冲突概率大，查询慢。
    *   如果是 0.5，冲突少，查询快，但空间浪费大，频繁扩容。
    *   0.75 是根据泊松分布（Poisson Distribution）统计学规律得出的一个折中值。
2.  **HashMap 线程安全吗？怎么办？**
    *   不安全。
    *   解决方案：
        1.  使用 `ConcurrentHashMap`（推荐，分段锁/CAS+Synchronized，高并发性能好）。
        2.  使用 `Collections.synchronizedMap(new HashMap<>())`（全表锁，性能差）。
